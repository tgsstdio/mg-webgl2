FREQUENT TRANSFER_DST !(HOST_COHERENT_BIT)
DEVICE_LOCAL_BIT
gl.STATIC_COPY: Contents of the buffer are likely to be used often and not change often. Contents are neither written or read by the user.
DEVICE_LOCAL_BIT | WRITE
gl.STATIC_DRAW: Contents of the buffer are likely to be used often and not change often. Contents are written to the buffer, but not read.
DEVICE_LOCAL_BIT | HOST_VISIBLE_BIT | READ
gl.STATIC_READ: Contents of the buffer are likely to be used often and not change often. Contents are read from the buffer, but not written.

ONCE OFF TRANSFER_SRC HOST_VISIBLE_BIT STAGING
STREAM - The data store contents will be modified once and used at most a few times.
VERTEX DATA | INDEX BUFFER | UNIFORM_BUFFER | TRANSFER_DST
STATIC - The data store contents will be modified once and used many times.
VERTEX DATA | INDEX BUFFER | UNIFORM_BUFFER | HOST_VISIBLE_BIT | COHERANT | HOST_CACHED_BIT
DYNAMIC - The data store contents will be modified repeatedly and used many times.

HOST_COHERENT_BIT
gl.STREAM_DRAW: Contents of the buffer are likely to not be used often. Contents are written to the buffer, but not read.
HOST_VISIBLE_BIT
gl.STREAM_READ: Contents of the buffer are likely to not be used often. Contents are read from the buffer, but not written.
0
gl.STREAM_COPY: Contents of the buffer are likely to be used often and not change often. Contents are neither written or read by the user.

FREQUENT 
HOST_CACHED_BIT | HOST_VISIBLE_BIT
gl.DYNAMIC_READ: Contents of the buffer are likely to be used often and change often. Contents are read from the buffer, but not written.
HOST_CACHED_BIT
gl.DYNAMIC_COPY: Contents of the buffer are likely to be used often and change often. Contents are neither written or read by the user.
HOST_CACHED_BIT | HOST_COHERENT_BIT 
gl.DYNAMIC_DRAW: Contents of the buffer are likely to be used often and change often. Contents are written to the buffer, but not read.

STREAM_COPY => images

DEVICE_LOCAL_BIT => STREAM_
DEVICE_LOCAL_BIT => TRANSFER_DST | VERTEX | INDEX | UNIFORM
TRANSFER_SRC => VERTEX | INDEX | UNIFORM
STATIC => VERTEX | INDEX | UNIFORM 
STATIC => UNIFORM
READ => QUERY
HOST_VISIBLE_BIT => READ | WRITE => _READ | _DRAW 
VERTEX | INDEX | UNIFORM  => WRITE => _DRAW
!HOST_VISIBLE_BIT => !( READ | WRITE )  => COPY
!(HOST_COHERENT_BIT) => STATIC
HOST_COHERENT_BIT => READ _READ | WRITE _READ
				  => DYNAMIC

HOST_COHERENT_BIT => USE FENCES AND SEMAPHORES 
				  => DYNAMIC
HOST_COHERENT_BIT => MAP_PERSISTENT_BIT | HOST_COHERENT_BIT
				  => HOST_VISIBLE_BIT | HOST_COHERENT_BIT
				  => READ _READ | WRITE _READ

GL_STATIC_DRAW 
 => TRANSFER_SRC
 
GL_DYNAMIC_DRAW
 => MAPPABLE
 

		/// <summary>
		/// If otherwise stated, then allocate memory on device
		/// </summary>
		DEVICE_LOCAL_BIT = 1 << 0,

		/// <summary>
		/// Memory is mappable by host 
		/// </summary>
		HOST_VISIBLE_BIT = 1 << 1,
		-> gl.DYNAMIC_*	
		
		/// <summary>
		/// Memory will have i/o coherency. If not set, application may need to use vkFlushMappedMemoryRanges and vkInvalidateMappedMemoryRanges to flush/invalidate host cache
		/// </summary>
		HOST_COHERENT_BIT = 1 << 2,
		-> _READ
		-> _WRITE

		/// <summary>
		/// Memory will be cached by the host
		/// </summary>
		HOST_CACHED_BIT = 1 << 3,
		-> gl.DYNAMIC_*		
		
		
		/// <summary>
		/// Memory may be allocated by the driver when it is required
		/// </summary>
		LAZILY_ALLOCATED_BIT = 1 << 4,
		
https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_buffer_storage.txt		
		
        DYNAMIC_STORAGE_BIT   The contents of the data store may be
    updated after creation through calls to BufferSubData. If this bit is not
    set, the buffer content may not be directly updated by the client. The
    <data> argument may be used to specify the initial content of the buffer's
    data store regardless of the presence of the DYNAMIC_STORAGE_BIT.
    Regardless of the presence of this bit, buffers may always be updated
    with server-side calls such as CopyBufferSubData and ClearBufferSubData.

        MAP_READ_BIT  The buffer's data store may be mapped by the client for
    read access and a pointer in the client's address space obtained that may
    be read from.

        MAP_WRITE_BIT  The buffer's data store may be mapped by the client for
    write access and a pointer in the client's address space obtained that may
    be written to.

        MAP_PERSISTENT_BIT  The client may request that the server read from
    or write to the buffer while it is mapped. The client's pointer to the
    data store remains valid so long as the data store is mapped, even during
    execution of drawing or dispatch commands.

        MAP_COHERENT_BIT  Shared access to buffers that are simultaneously
    mapped for client access and are used by the server will be coherent, so
    long as that mapping is performed using MapBufferRange. That is, data
    written to the store by either the client or server will be immediately
    visible to the other with no further action taken by the application. In
    particular:

        - If MAP_COHERENT_BIT is not set and the client performs a write
          followed by a call to one of the FlushMapped*BufferRange commands
          with a range including the written range, then in subsequent
          commands the server will see the writes.

        - If MAP_COHERENT_BIT is set and the client performs a write, then in
          subsequent commands the server will see the writes.

        - If MAP_COHERENT_BIT is not set and the server performs a write, the
          application must call MemoryBarrier with the
          CLIENT_MAPPED_BUFFER_BARRIER_BIT set and then call FenceSync with
          SYNC_GPU_COMMANDS_COMPLETE (or Finish). Then the CPU will see the
          writes after the sync is complete.

        - If MAP_COHERENT_BIT is set and the server does a write, the app must
          call FenceSync with SYNC_GPU_COMMANDS_COMPLETE (or Finish). Then the
          CPU will see the writes after the sync is complete.

        CLIENT_STORAGE_BIT  When all other criteria for the buffer storage
    allocation are met, this bit may be used by an implementation to determine
    whether to use storage that is local to the server or to the client to
    serve as the backing store for the buffer.		
	
GL_ARRAY_BUFFER	Vertex attributes
GL_ATOMIC_COUNTER_BUFFER	Atomic counter storage
GL_COPY_READ_BUFFER	Buffer copy source
GL_COPY_WRITE_BUFFER	Buffer copy destination
GL_DISPATCH_INDIRECT_BUFFER	Indirect compute dispatch commands
GL_DRAW_INDIRECT_BUFFER	Indirect command arguments
GL_ELEMENT_ARRAY_BUFFER	Vertex array indices
GL_PIXEL_PACK_BUFFER	Pixel read target
GL_PIXEL_UNPACK_BUFFER	Texture data source
GL_QUERY_BUFFER	Query result buffer
GL_SHADER_STORAGE_BUFFER	Read-write storage for shaders
GL_TEXTURE_BUFFER	Texture data buffer
GL_TRANSFORM_FEEDBACK_BUFFER	Transform feedback buffer
GL_UNIFORM_BUFFER	Uniform block storage	